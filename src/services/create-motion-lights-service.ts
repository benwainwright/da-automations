import type { TServiceParams, TOffset } from "@digital-alchemy/core";
import type { PICK_ENTITY, TAreaId } from "@digital-alchemy/hass";

interface IMotionSwitchConfig {
  /**
   * Motion trigger will only activate if this switch is turned on
   */
  switchName: string;
  /**
   * Lights in this area are controllled by the motion sensor
   */
  area: TAreaId;

  /**
   * A binary sensor generated by a motion sensor
   */
  sensorId: PICK_ENTITY<"binary_sensor">;

  /**
   * If any of these switches are turned on, the motion sensor will *not* fire
   */
  blockSwitches?: PICK_ENTITY<"switch">[];

  /**
   * The time interval before a switch is turned off
   */
  timeout: TOffset;
}

/**
 * Create a motion sensor controlled light
 */
export function CreateMotionLightService({
  synapse,
  context,
  scheduler,
  hass,
  logger,
}: TServiceParams) {
  const create = ({ switchName, sensorId, area, timeout, blockSwitches }: IMotionSwitchConfig) => {
    const theSwitch = synapse.switch({
      name: switchName,
      attributes: {
        area,
      },
      context,
    });

    const theSensor = hass.refBy.id(sensorId);

    theSensor.onUpdate(async (newState) => {
      logger.info(`${sensorId} sensor triggered`);
      if (!newState) {
        return;
      }
      const anyBlockSwitchIsOn = blockSwitches
        ?.map(hass.refBy.id)
        .some((theSwitch) => theSwitch.state === "on");

      if (newState.state === "on" && theSwitch.is_on && !anyBlockSwitchIsOn) {
        logger.info(`Turning ${area} lights on`);
        await hass.call.light.turn_on({ area_id: area });
        scheduler.setTimeout(async () => {
          logger.info(`Turning ${area} lights on`);
          await hass.call.light.turn_off({ area_id: area });
        }, timeout);
      }
    });
  };

  return { create };
}
