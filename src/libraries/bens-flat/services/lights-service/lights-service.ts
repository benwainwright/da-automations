import type { TServiceParams, TOffset } from "@digital-alchemy/core";
import type { PICK_ENTITY, RemoveCallback, TAreaId } from "@digital-alchemy/hass";
import { toSynapseUniqueId } from "../unique-id.ts";

interface IMotionSwitchConfig {
  /**
   * Motion trigger will only activate if this switch is turned on
   */
  switchName: string;
  /**
   * Lights in this area are controlled by the motion sensor
   */
  area: TAreaId;

  /**
   * A binary sensor generated by a motion sensor
   */
  sensorId: PICK_ENTITY<"binary_sensor">;

  /**
   * If any of these switches are turned on, the motion sensor will *not* fire
   */
  blockSwitches?: PICK_ENTITY<"switch">[];

  /**
   * The time interval before a switch is turned off
   */
  timeout: TOffset;
}

/**
 * Create a motion sensor controlled light
 */
export function LightsService({
  synapse,
  context,
  scheduler,
  hass,
  logger,
  bens_flat,
}: TServiceParams) {
  const { helpers } = bens_flat;

  const turnOffAll = async () => {
    const lights = hass.refBy.domain(`light`);
    await helpers.turnOffAll(lights.map((entity) => entity.entity_id));
  };

  const flash = async () => {
    await hass.call.light.turn_on({
      effect: "okay",
      area_id: ["bathroom", "bedroom", "hallway", "spare_room"],
    });
  };

  const setupMotionTrigger = ({
    switchName,
    sensorId,
    area,
    timeout,
    blockSwitches,
  }: IMotionSwitchConfig) => {
    const motionSwitch = synapse.switch({
      name: switchName,
      unique_id: toSynapseUniqueId(switchName),
      suggested_object_id: toSynapseUniqueId(switchName),
      attributes: {
        area,
      },
      context,
    });

    let remove: RemoveCallback | undefined;

    const theSensor = hass.refBy.id(sensorId);

    theSensor.onUpdate(async (newState) => {
      if (!newState) {
        return;
      }
      const anyBlockSwitchIsOn = blockSwitches
        ?.map(hass.refBy.id)
        .some((theSwitch) => theSwitch.state === "on");

      const switchEntity = motionSwitch?.getEntity?.();
      const switchIsOn = switchEntity?.state === "on";
      if (!switchEntity) {
        logger.warn(`Skipping motion trigger for ${area}; switch entity is unavailable`);
        return;
      }

      if (newState.state === "on" && switchIsOn && !anyBlockSwitchIsOn) {
        logger.info(`Turning ${area} lights on`);
        remove?.remove();
        await hass.call.light.turn_on({ area_id: area });
        remove = scheduler.setTimeout(async () => {
          logger.info(`Turning ${area} lights off`);
          await hass.call.light.turn_off({ area_id: area });
        }, timeout);
      }
    });
  };

  return { setupMotionTrigger, turnOffAll, flash };
}
